@file:JvmName("CryptoUtils")
package io.slychat.messenger.core.crypto

import io.slychat.messenger.core.crypto.ciphers.Key
import io.slychat.messenger.core.crypto.hashes.*
import io.slychat.messenger.core.hexify
import org.whispersystems.libsignal.IdentityKey
import org.whispersystems.libsignal.IdentityKeyPair
import org.whispersystems.libsignal.util.KeyHelper
import java.security.SecureRandom

private const val MASTER_KEY_SIZE_BITS = 256
private const val ANONYMIZING_DATA_SIZE_BITS = 128

/** Default parameters for hashing a password into a key for decrypting the encrypted key pair. */
fun defaultKeyPasswordHashParams(): HashParams {
    val keyLength = 32
    val salt = getRandomBits(keyLength * 8)

    //TODO tune?
    //default recommendations from: https://www.tarsnap.com/scrypt/scrypt-slides.pdf
    val N = 16384
    val r = 8
    val p = 1

    return SCryptParams(
        salt,
        N,
        r,
        p,
        keyLength
    )
}

fun defaultRemotePasswordHashParams(): HashParams {
    //TODO calc this; 15 is too slow, 12 seems like a decent number time-wise
    val cost = 12
    val salt = getRandomBits(128)
    return BCryptParams(salt, cost)
}

fun generateKeyPair(): IdentityKeyPair = KeyHelper.generateIdentityKeyPair()

/**
 * Generates a hash for using the password as a symmetric encryption key.
 */
fun hashPasswordForLocalWithDefaults(password: String): HashData {
    val params = defaultKeyPasswordHashParams()
    return HashData(hashDataWithParams(password.toByteArray(Charsets.UTF_8), params), params)
}

/** Used to generate a password hash for a new password during registration. Uses the current default algorithm. */
fun hashPasswordForRemoteWithDefaults(password: String): HashData {
    val params = defaultRemotePasswordHashParams()
    return HashData(hashPasswordWithParams(password, params), params)
}

/** Return a randomly generated ByteArray of the given bit size. */
fun getRandomBits(bits: Int): ByteArray {
    require(bits >= 8) { "bits must be > 8" }
    require((bits % 8) == 0) { "bits must be a multiple of 8" }

    val iv = ByteArray(bits/8)
    SecureRandom().nextBytes(iv)
    return iv
}

/** Generate new anonymizing data. */
fun generateAnonymizingData(): ByteArray {
    return getRandomBits(ANONYMIZING_DATA_SIZE_BITS)
}

/** Generate a new master key. */
fun generateMasterKey(): Key {
    return generateKey(MASTER_KEY_SIZE_BITS)
}

/** Generate a key of the given key size (in bits). */
fun generateKey(keySizeBits: Int): Key {
    return Key(getRandomBits(keySizeBits))
}

/** Generates a new key vault for a new user. */
fun generateNewKeyVault(password: String): KeyVault {
    val identityKeyPair = generateKeyPair()
    val masterKey = generateMasterKey()
    val anonymizingData = generateAnonymizingData()
    val keyPasswordHashInfo = hashPasswordForLocalWithDefaults(password)

    return KeyVault(
        identityKeyPair,
        masterKey,
        anonymizingData,
        keyPasswordHashInfo.params,
        Key(keyPasswordHashInfo.hash)
    )
}

/** Returns a textual fingerprint of the given identity key. */
fun identityKeyFingerprint(identityKey: IdentityKey): String =
    identityKey.publicKey.serialize().hexify()

/** Returns a random UUID as a string, without dashes. */
fun randomUUID(): String {
    val bytes = ByteArray(16)
    SecureRandom().nextBytes(bytes)
    return bytes.hexify()
}

private val uuidRegex = "[0-9a-f]{32}".toRegex()
fun isValidUUIDFormat(s: String): Boolean {
    return uuidRegex.matches(s)
}

fun randomRegistrationId(): Int = KeyHelper.generateRegistrationId(false)

fun randomMessageId(): String = randomUUID()
