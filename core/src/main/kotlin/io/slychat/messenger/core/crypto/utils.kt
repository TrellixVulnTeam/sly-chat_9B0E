@file:JvmName("CryptoUtils")
package io.slychat.messenger.core.crypto

import io.slychat.messenger.core.crypto.ciphers.*
import io.slychat.messenger.core.crypto.hashes.*
import io.slychat.messenger.core.hexify
import org.whispersystems.libsignal.IdentityKey
import org.whispersystems.libsignal.IdentityKeyPair
import org.whispersystems.libsignal.util.KeyHelper
import java.security.SecureRandom

/** Default parameters for local data encryption. */
fun defaultDataEncryptionParams(): CipherParams =
    //12b is the default IV size
    AESGCMParams(getRandomBits(96), 128)

/** Default parameters for hashing a password into a key for decrypting the encrypted key pair. */
fun defaultKeyPasswordHashParams(): HashParams {
    val keyLength = 32
    val salt = getRandomBits(keyLength * 8)

    //TODO tune?
    //default recommendations from: https://www.tarsnap.com/scrypt/scrypt-slides.pdf
    val N = 16384
    val r = 8
    val p = 1

    return SCryptParams(
        salt,
        N,
        r,
        p,
        keyLength
    )
}

fun defaultRemotePasswordHashParams(): HashParams {
    //TODO calc this; 15 is too slow, 12 seems like a decent number time-wise
    val cost = 12
    val salt = getRandomBits(128)
    return BCryptParams(salt, cost)
}

fun generateKeyPair(): IdentityKeyPair = KeyHelper.generateIdentityKeyPair()

/**
 * Generates a hash for using the password as a symmetric encryption key. The generate key should have the same key
 * length as the corresponding cipher.
 */
fun hashPasswordForLocalWithDefaults(password: String): HashData {
    val params = defaultKeyPasswordHashParams()
    return HashData(hashDataWithParams(password.toByteArray(Charsets.UTF_8), params), params)
}

/** Used to generate a password hash for a new password during registration. Uses the current default algorithm. */
fun hashPasswordForRemoteWithDefaults(password: String): HashData {
    val params = defaultRemotePasswordHashParams()
    return HashData(hashPasswordWithParams(password, params), params)
}

/** Converts a private key for use as a symmetric key. Currently returns a 256bit key. */
fun privateKeyToSymmetricKey(privateKeyBytes: ByteArray): HashData {
    val params = SHA256Params(ByteArray(0))
    return HashData(hashDataWithParams(privateKeyBytes, params), params)
}

/** Return a randomly generated ByteArray of the given bit size. */
fun getRandomBits(bits: Int): ByteArray {
    io.slychat.messenger.core.require(bits >= 8, "bits must be > 8")
    io.slychat.messenger.core.require((bits % 8) == 0, "bits must be a multiple of 8")

    val iv = ByteArray(bits/8)
    SecureRandom().nextBytes(iv)
    return iv
}

/** Generates a new key vault for a new user. For use during registration. */
fun generateNewKeyVault(password: String): KeyVault {
    val identityKeyPair = generateKeyPair()
    val keyPasswordHashInfo = hashPasswordForLocalWithDefaults(password)

    val localEncryptionKeyInfo = privateKeyToSymmetricKey(identityKeyPair.privateKey.serialize())

    return KeyVault(
        identityKeyPair,
        keyPasswordHashInfo.hash,
        keyPasswordHashInfo.params,
        defaultDataEncryptionParams(),
        localEncryptionKeyInfo.params,
        localEncryptionKeyInfo.hash,
        defaultDataEncryptionParams()
    )
}

/** Encrypts data using the default settings. */
fun encryptDataWithDefaults(key: ByteArray, plaintext: ByteArray): EncryptedData {
    val params = defaultDataEncryptionParams()
    return encryptDataWithParams(EncryptionSpec(key, params), plaintext)
}

fun identityKeyFingerprint(identityKey: IdentityKey): String =
    identityKey.publicKey.serialize().hexify()

/** Returns a random UUID as a string, without dashes. */
fun randomUUID(): String {
    val bytes = ByteArray(16)
    SecureRandom().nextBytes(bytes)
    return bytes.hexify()
}

private val uuidRegex = "[0-9a-f]{32}".toRegex()
fun isValidUUIDFormat(s: String): Boolean {
    return uuidRegex.matches(s)
}

fun randomRegistrationId(): Int = KeyHelper.generateRegistrationId(false)

fun randomMessageId(): String = randomUUID()
